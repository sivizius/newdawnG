;( opcodes )
;{
  fbc0@@opPushByte                      =                                       0x01
  fbc0@@opPushWord                      =                                       0x02
  fbc0@@opPushDWord                     =                                       0x03
  fbc0@@opPushQWord                     =                                       0x04
  fbc0@@opAdd                           =                                       0x10
  fbc0@@opSub                           =                                       0x11
  fbc0@@opMul                           =                                       0x12
  fbc0@@opDiv                           =                                       0x13
  fbc0@@opMod                           =                                       0x14
  fbc0@@opLet                           =                                       0x20
  fbc0@@opCall                          =                                       0x21
  fbc0@@opAllocGlobal                   =                                       0xfb
  fbc0@@opAllocLocal                    =                                       0xfc
  fbc0@@opAllocate                      =                                       0xfd
  fbc0@@opLbl                           =                                       0xfe
  fbc0@@opStop                          =                                       0xff
;}
macro fbc0@@disassemble                 context*, address*, size*, main*
  local pointer, instruction, temp, lenght, char
  local previousInstruction, previousValue
  pointer                               =                                       null
  while ( pointer < size )
    load                                instruction byte                        from context#:( address + pointer )
    if ( pointer = main )
      db '->'
    else
      db '  '
    end if
    db '0x'
    hw pointer
    db ' '
    pointer                             =                                       ( pointer + 1 )
    if ( instruction = fbc0@@opLbl )
      load                              temp qword                              from context#:( address + pointer )
      pointer                           =                                       ( pointer + 8 )
      if      ( disasm@@ptrStringYapter = null )
        err 10, '[fbc] there is no string-yapter'
        break
      else if (( temp < 2 ) | (( disasm@@lenStringYapter - temp ) < 0 ))
        err 10, '[fbc] pointer out of bonds'
        break
      else
        load                            lenght word                             from context#:( disasm@@ptrStringYapter + temp - 2 )
        if (( disasm@@lenStringYapter - temp ) < lenght )
          err 10, '[fbc] corrupted string'
          break
        end if
        repeat ( lenght )
          load                          char byte                               from context#:( disasm@@ptrStringYapter + temp + % - 1 )
          db char
        end repeat
        db ':'
      end if
    else
      db '  '
    end if
    if false
    else if ( instruction = fbc0@@opPushByte )
      load                              temp byte                               from context#:( address + pointer )
      pointer                           =                                       ( pointer + 1 )
      db 'pushByte 0x'
      hb ( temp )
    else if ( instruction = fbc0@@opPushWord )
      load                              temp word                               from context#:( address + pointer )
      pointer                           =                                       ( pointer + 2 )
      db 'pushWord 0x'
      hw ( temp )
    else if ( instruction = fbc0@@opPushDWord )
      load                              temp dword                              from context#:( address + pointer )
      pointer                           =                                       ( pointer + 4 )
      db 'pushDWord 0x'
      hd ( temp )
    else if ( instruction = fbc0@@opPushQWord )
      load                              temp qword                              from context#:( address + pointer )
      pointer                           =                                       ( pointer + 8 )
      db 'pushQWord 0x'
      hq ( temp )
    else if ( instruction = fbc0@@opAdd )
      db 'add'
    else if ( instruction = fbc0@@opSub )
      db 'sub'
    else if ( instruction = fbc0@@opMul )
      db 'mul'
    else if ( instruction = fbc0@@opDiv )
      db 'div'
    else if ( instruction = fbc0@@opMod )
      db 'mod'
    else if ( instruction = fbc0@@opLet )
      db 'let'
    else if ( instruction = fbc0@@opStop )
      db 'stop'
    else if ( instruction = fbc0@@opCall )
      db 'call'
      if (( previousInstruction = fbc0@@opPushByte  ) | \
          ( previousInstruction = fbc0@@opPushWord  ) | \
          ( previousInstruction = fbc0@@opPushDWord ) | \
          ( previousInstruction = fbc0@@opPushQWord ))
        load                            temp byte                               from context#:( address + previousValue )
        if ( temp = fbc0@@opLbl )
          load                          temp qword                              from context#:( address + previousValue + 1 )
          if      ( disasm@@ptrStringYapter = null )
            err 10, '[fbc] there is no string-yapter'
            break
          else if (( temp < 2 ) | (( disasm@@lenStringYapter - temp ) < 0 ))
            err 10, '[fbc] pointer out of bonds'
            break
          else
            load                        lenght word                             from context#:( disasm@@ptrStringYapter + temp - 2 )
            if (( disasm@@lenStringYapter - temp ) < lenght )
              err 10, '[fbc] corrupted string'
              break
            end if
            db ' »'
            repeat ( lenght )
              load                      char byte                               from context#:( disasm@@ptrStringYapter + temp + % - 1 )
              db char
            end repeat
            db '«'
          end if
        end if
      end if
    else if ( instruction = fbc0@@opLbl )
    else if ( instruction = fbc0@@opAllocGlobal )
      db 'allocGlobal'
    else if ( instruction = fbc0@@opAllocLocal )
      db 'allocLocal'
    else if ( instruction = fbc0@@opAllocate )
      db 'allocate'
    else
      db '<0x'
      hb instruction
      db '>'
    end if
    previousValue                       =                                       temp
    previousInstruction                 =                                       instruction
    db 10
  end while
  display 'done', 10
end macro
macro pushByte                          value*
  ;displayValue 'pushByte 0x', value
  fbc0@@instruction                     fbc0@@opPushByte
  fbc0@@operantByte                     value
end macro
macro pushWord                          value*
  ;displayValue 'pushWord 0x', value
  fbc0@@instruction                     fbc0@@opPushWord
  fbc0@@operantWord                     value
end macro
macro pushDWord                         value*
  ;displayValue 'pushDWord 0x', value
  fbc0@@instruction                     fbc0@@opPushDWord
  fbc0@@operantDWord                    value
end macro
macro pushQWord                         value*
  ;displayValue 'pushQWord 0x', value
  fbc0@@instruction                     fbc0@@opPushQWord
  fbc0@@operantQWord                    value
end macro
macro pushConstant                      value*
  ;displayValue 'pushConstant 0x', value
  if      (( value >= -( 1 shl  7 )) & ( value < ( 1 shl  7 )))
    pushByte                            value
  else if (( value >= -( 1 shl 15 )) & ( value < ( 1 shl 15 )))
    pushWord                            value
  else if (( value >= -( 1 shl 31 )) & ( value < ( 1 shl 31 )))
    pushDWord                           value
  else
    pushQWord                           value
  end if
end macro
macro add                               ignore
  fbc0@@instruction                     fbc0@@opAdd
end macro
macro sub                               ignore
  fbc0@@instruction                     fbc0@@opSub
end macro
macro mul                               ignore
  fbc0@@instruction                     fbc0@@opMul
end macro
macro div                               ignore
  fbc0@@instruction                     fbc0@@opDiv
end macro
macro mod                               ignore
  fbc0@@instruction                     fbc0@@opMod
end macro
macro let                               ignore
  fbc0@@instruction                     fbc0@@opLet
end macro
macro stop                              ignore
  fbc0@@instruction                     fbc0@@opStop
end macro
macro call                              address*
  local temp
  temp                                  fbc0@@getToken
  pushConstant                          ( address - temp.lenString )
  fbc0@@instruction                     fbc0@@opCall
end macro
macro allocGlobal                       ignore
  fbc0@@instruction                     fbc0@@opAllocGlobal
end macro
macro allocLocal                        ignore
  fbc0@@instruction                     fbc0@@opAllocLocal
end macro
macro allocate                          ignore
  fbc0@@instruction                     fbc0@@opAllocate
end macro
macro lbl                               name
  fbc0@@instruction                     fbc0@@opLbl
  fbc0@@operantString                   `name
end macro
macro fbc0@@killMySelf
  purge pushByte, pushWord, pushDWord, pushQWord
  purge add, sub, mul, div, mod
end macro