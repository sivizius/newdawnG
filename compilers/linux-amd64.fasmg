Include 'include/main.flibg'
Include 'include/format.flibg'
Include 'include/display.flibg'
Include 'include/fruitbot/version_0.flibg'
Include 'include/fruitbot/opcodes.flibg'

compile@@ptrStringYapter                =                                       null
compile@@lenStringYapter                =                                       null
compile@@lenMagic                       =                                       null

Include 'include/yasic/queque.flibg'
yasic@@lenQueque                        =                                       ( 4096 * 16 )
yasic@@ptrQueque                        =                                       null
yasic@@endQueque                        =                                       null
Virtual                                 At null
  yasic@@lblQueque::
    rb                                  ( yasic@@lenQueque )
End Virtual

Include 'include/yasic/stack.flibg'
yasic@@lenStack                         =                                       ( 4096 * 16 )
yasic@@ptrStack                         =                                       null
yasic@@topStack                         =                                       null
Virtual                                 At null
  yasic@@lblStack::
    rb                                  ( yasic@@lenStack )
End Virtual
yasic@@lenHelpStack                     =                                       ( 4096 * 16 )
yasic@@ptrHelpStack                     =                                       null
yasic@@topHelpStack                     =                                       null
Virtual                                 At null
  yasic@@lblHelpStack::
    rb                                  ( yasic@@lenHelpStack )
End Virtual
Struc yasic@@popArgument
  Local tmp, op1, op2
  tmp yasic@@pop
  If      ( tmp.type = fbc0@@tConstant )
    .type                               =                                       fbc0@@tConstant
    .misc                               =                                       null
    .size                               =                                       null
    .value                              =                                       tmp.value
  Else if ( tmp.type = fbc0@@tOperator )
    If      ( tmp.value = fbc0@@opAdd )
      op1 yasic@@popArgument
      op2 yasic@@popArgument
      If (( op1.type = fbc0@@tConstant ) & ( op2.type = fbc0@@tConstant ))
        .type                           =                                       fbc0@@tConstant
        .misc                           =                                       null
        .size                           =                                       null
        .value                          =                                       ( op1.value + op2.value )
      End If
    Else If ( tmp.value = fbc0@@opSub )
      op1 yasic@@popArgument
      op2 yasic@@popArgument
    Else
      tmp fbc0@@mnemonic
      fail < '[asm:compile] invalid operator: »', tmp, '«' >
    End if
  End If
End Struc

Macro compile@@pushCall                 address*,                               queque*
  If ( compile@@ptrCallStack >= compile@@lenCallStack )
    fail '[asm:compile] call-stack to small. adjust compile@@lenCallStack'
  End If
  Store                                 dword address                           At compile@@lblCallStack:( compile@@ptrCallStack + 0x00 )
  Store                                 dword queque                            At compile@@lblCallStack:( compile@@ptrCallStack + 0x04 )
  compile@@ptrCallStack                 =                                       ( compile@@ptrCallStack + 8 )
End Macro
Struc compile@@peekCall                 offs:0
  If ( compile@@ptrCallStack < null )
    fail '[asm:compile] call-stack is empty'
  End If
  Local address, queque
  Load                                  address dword                           From compile@@lblCallStack:( compile@@ptrCallStack - ( 8 * offs ) + 0x00 )
  Load                                  queque  dword                           From compile@@lblCallStack:( compile@@ptrCallStack - ( 8 * offs ) + 0x04 )
  .address                              =                                       address
  .queque                               =                                       queque
End Struc
Struc compile@@popCall
  Local temp
  compile@@ptrCallStack                 =                                       ( compile@@ptrCallStack - 8 )
  temp                                  compile@@peekCall
  .address                              =                                       temp.address
  .queque                               =                                       temp.queque
End Struc
compile@@lenCallStack                   =                                       ( 4096 * 8 )
compile@@ptrCallStack                   =                                       null
Virtual                                 At null
  compile@@lblCallStack::
    rb                                  ( compile@@lenCallStack )
End Virtual
;( modules )
;{
  compile@@initModules                  Equ
  compile@@finishModules                Equ
  Include 'modules/linux/echo.fmodg'
;}
Macro compile@@decode                   context*, address*, size*, main*
  Local lblFunctions, ctrFunctions, numFunctions, lenFunctions, theFunction, hazFunction, offFunction
  ctrFunctions                          =                                       null
  lenFunctions                          =                                       16
  Virtual                               At null
    lblFunctions::
      rd                                numFunctions                            ;fbc address
      rd                                numFunctions                            ;new address
      rd                                numFunctions                            ;size
      rd                                numFunctions                            ;
  End Virtual
  Local operator
  Macro operator                        name*,                                  value*
    If ( yasic@@ptrStack < 32 )
      fail < '[asm:compile] ', name, ' need 2 arguments in stack' >
    End If
    display '  ', name, 10
    yasic@@push                         fbc0@@tOperator,                        ( value )
  End Macro
  Local ptrStart, ptrStopp, ptrMain
  ptrStart                              =                                       ( address )
  ptrStopp                              =                                       ( address + size )
  If (( main >= null ) & ( main < size ))
    ptrMain                             =                                       ( ptrStart + main )
  Else
    ptrMain                             =                                       ( ptrStart )
  End If
  Local instruction, value, temp
  Local numArguments
  While ( true )
    If (( ptrMain < ptrStart ) | ( ptrMain >= ptrStopp ))
      fail '[asm:compile:linux-amd64] invalid instruction-pointer'
    End If
    Load                                instruction byte                        From context:( ptrMain )
    ;displayValue 'addr: 0x', ptrMain
    ptrMain                             =                                       ( ptrMain + 1 )
    ;displayValue 'inst: 0x', instruction
    If      ( instruction = fbc0@@opPushByte )
      Load                              value byte                              From context:( ptrMain )
      displayValue '  pushByte 0x', value
      ptrMain                           =                                       ( ptrMain + 1 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x00000080 ) * 0xffffffffffffff00 ) or value )
    Else if ( instruction = fbc0@@opPushWord )
      Load                              value word                              From context:( ptrMain )
      displayValue '  pushWord 0x', value
      ptrMain                           =                                       ( ptrMain + 2 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x00008000 ) * 0xffffffffffff0000 ) or value )
    Else if ( instruction = fbc0@@opPushDWord )
      Load                              value dword                             From context:( ptrMain )
      displayValue '  pushDWord 0x', value
      ptrMain                           =                                       ( ptrMain + 4 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x80000000 ) * 0xffffffff00000000 ) or value )
    Else if ( instruction = fbc0@@opPushQWord )
      Load                              value qword                             From context:( ptrMain )
      displayValue '  pushQWord 0x', value
      ptrMain                           =                                       ( ptrMain + 8 )
      yasic@@push                       fbc0@@tConstant,                        ( value )
    Else if ( instruction = fbc0@@opAdd )
      operator                          'add',                                  instruction
    Else if ( instruction = fbc0@@opSub )
      operator                          'sub',                                  instruction
    Else if ( instruction = fbc0@@opMul )
      operator                          'mul',                                  instruction
    Else if ( instruction = fbc0@@opDiv )
      operator                          'div',                                  instruction
    Else if ( instruction = fbc0@@opMod )
      operator                          'mod',                                  instruction
    Else if ( instruction = fbc0@@opLbl )
      Load                              temp qword                              from context:( ptrMain )
      If      ( compile@@ptrStringYapter = null )
        fail '[asm:compile:linux-amd64] there is no string-yapter'
      Else If (( temp < 2 ) | (( compile@@lenStringYapter - temp ) < 0 ))
        fail '[asm:compile:linux-amd64] pointer out of bonds'
      Else
        Load                            lenght word                             from context:( compile@@ptrStringYapter + temp - 2 )
        ptrMain                         =                                       ( ptrMain + 8 )
        If (( compile@@lenStringYapter - temp ) < lenght )
          fail '[asm:compile:linux-amd64] corrupted string'
        End If
        Repeat ( lenght )
          Load                          char byte                               from context:( compile@@ptrStringYapter + temp + % - 1 )
          display char
        End Repeat
        display ':', 10
      End If
    Else if ( instruction = fbc0@@opCall )
      display '  call', 10
      temp yasic@@popArgument
      If ( temp.type = fbc0@@tConstant )
        hazFunction                     =                                       nil
        Repeat ( ctrFunctions ), offFunction:( 0 )
          Load                          theFunction dword                       lblFunctions:(( offFunction * lenFunctions ) + 0x00 )
          If ( theFunction = temp.value )
            hazFunction                 =                                       offFunction
            Break
          End If
        End Repeat
        If ( hazFunction = nil )
          compile@@pushCall             ( ptrMain - 1 ),                        yasic@@ptrQueque
          If (( temp.value >= null ) & ( temp.value < size ))
            ptrMain                     =                                       ( ptrStart + temp.value )
            yasic@@ptrQueque            =                                       yasic@@endQueque
          Else
            fail '[asm:compiler:linux-amd64] call of function with an invalid address failed'
          End If
        End If
      Else
        fail '[asm:compile:linux-amd64] this type of call is not implemented yet'
      End If
    Else
      temp fbc0@@mnemonic               instruction
      displayValue 'instruction: 0x', instruction
      fail < '[asm:compile:linux-amd64] invalid instruction: »', temp, '«' >
    End If
  End While
  Purge operator
  numFunctions                          =                                       ( ctrFunctions )
End Macro
Macro compile@@buildYapter              address,  type,     size,     resv,     misc,     pointer,  dword0,   dword1,   dword2,   lblInputFile
  If ( compile@@lenMagic = 0 )
    compile@@lenMagic                   =                                       ( address )
    Repeat ( compile@@lenMagic )
      Load                              char byte                               From lblInputFile:( % - 1 )
      db                                char
    End Repeat
  End If
  If      ( type = null )
    compile@@ycontent                   =                                       ( address + 16 )
    Break
  Else If ( type = fbc0@@yBytecode )
    dw type, size
    dd dword0,   dword1,   dword2
  Else If ( type = fbc0@@yStrings )
    dw type, size
    dd dword0,   dword1,   dword2
    compile@@ptrStringYapter            =                                       ( dword1 + compile@@ycontent )
    compile@@lenStringYapter            =                                       dword0
;    displayValue '*0x', compile@@ptrStringYapter
  Else
    displayValue 'type: 0x', type
    fail '[asm:compile:linux-amd64] unknown yapter-type'
  End If
End Macro
Macro compile@@loadYapter               address,  type,     size,     resv,     misc,     pointer,  dword0,   dword1,   dword2,   lblInputFile
  Local offs, lenght, char
  If      ( type = null )
    Break
  Else If ( type = fbc0@@yBytecode )
    If ( size = fbc0@@version )
      compile@@decode                   lblInputFile,                           ( dword2 + compile@@ycontent ),         dword0,   dword1
    End If
  Else If ( type = fbc0@@yStrings )
  End If
End Macro

uf4@@parseFile                          compile@@theInputFile,                  compile@@buildYapter,                   compile@@loadYapter
