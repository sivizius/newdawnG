Include 'include/main.flibg'
Include 'include/format.flibg'
Include 'include/display.flibg'
Include 'include/fruitbot/version_0.flibg'
Include 'include/fruitbot/opcodes.flibg'

compile@@ptrStringYapter                =                                       null
compile@@lenStringYapter                =                                       null
compile@@lenMagic                       =                                       null

Include 'include/yasic/queque.flibg'
yasic@@lenQueque                        =                                       ( 4096 * 16 )
yasic@@ptrQueque                        =                                       null
yasic@@endQueque                        =                                       null
Virtual                                 At null
  yasic@@lblQueque::
    rb                                  ( yasic@@lenQueque )
End Virtual

Include 'include/yasic/stack.flibg'
yasic@@lenStack                         =                                       ( 4096 * 16 )
yasic@@ptrStack                         =                                       null
yasic@@topStack                         =                                       null
Virtual                                 At null
  yasic@@lblStack::
    rb                                  ( yasic@@lenStack )
End Virtual
yasic@@lenHelpStack                     =                                       ( 4096 * 16 )
yasic@@ptrHelpStack                     =                                       null
yasic@@topHelpStack                     =                                       null
Virtual                                 At null
  yasic@@lblHelpStack::
    rb                                  ( yasic@@lenHelpStack )
End Virtual

Macro amd64@@defRegister                value*,                                 regs&
  Local name, size
  Irp < name, size >, regs
    
  End Irp
End Macro

Struc yasic@@popArgument                wantConstant:( false )
  Local tmp, op1, op2
  tmp yasic@@pop
  If      ( tmp.type = fbc0@@tConstant )
    .type                               =                                       fbc0@@tConstant
    .misc                               =                                       null
    .size                               =                                       null
    .value                              =                                       tmp.value
  Else if ( tmp.type = fbc0@@tOperator )
    If      ( tmp.value = fbc0@@opAdd )
      op2                               yasic@@popArgument                      wantConstant
      op1                               yasic@@popArgument                      wantConstant
      If (( op1.type = fbc0@@tConstant ) & ( op2.type = fbc0@@tConstant ))
        .type                           =                                       fbc0@@tConstant
        .misc                           =                                       null
        .size                           =                                       null
        .value                          =                                       ( op1.value + op2.value )
      Else If ( wantConstant = false )
        
      Else
        fail '[asm:compile] argument is not constant'
      End If
    Else If ( tmp.value = fbc0@@opSub )
      op2                               yasic@@popArgument                      wantConstant
      op1                               yasic@@popArgument                      wantConstant
      If (( op1.type = fbc0@@tConstant ) & ( op2.type = fbc0@@tConstant ))
        .type                           =                                       fbc0@@tConstant
        .misc                           =                                       null
        .size                           =                                       null
        .value                          =                                       ( op1.value - op2.value )
      Else If ( wantConstant = false )
      Else
        fail '[asm:compile] argument is not constant'
      End If
    Else
      tmp fbc0@@mnemonic
      fail < '[asm:compile] invalid operator: »', tmp, '«' >
    End if
  End If
End Struc

Struc compile@@pushCall                 theAddress*,                            ctrArguments:( null )
  If ( compile@@ptrCallStack >= compile@@lenCallStack )
    fail '[asm:compile] call-stack to small. adjust compile@@lenCallStack'
  End If
  Store                                 dword .                                 At compile@@lblCallStack:( compile@@ptrCallStack + 0x00 )
  Store                                 dword ctrArguments                      At compile@@lblCallStack:( compile@@ptrCallStack + 0x04 )
  Store                                 dword yasic@@ptrQueque                  At compile@@lblCallStack:( compile@@ptrCallStack + 0x08 )
  Store                                 dword yasic@@ptrStack                   At compile@@lblCallStack:( compile@@ptrCallStack + 0x0c )
  compile@@ptrCallStack                 =                                       ( compile@@ptrCallStack + compile@@sizeCallStack )
  .                                     =                                       theAddress
End Struc
Struc compile@@peekCall                 offs:0
  If ( compile@@ptrCallStack < null )
    fail '[asm:compile] call-stack is empty'
  End If
  Local theAddress, ctrArguments, ptrQueque, ptrStack
  Load                                  theAddress   dword                      From compile@@lblCallStack:( compile@@ptrCallStack - ( compile@@sizeCallStack * offs ) + 0x00 )
  Load                                  ctrArguments dword                      From compile@@lblCallStack:( compile@@ptrCallStack - ( compile@@sizeCallStack * offs ) + 0x04 )
  Load                                  ptrQueque    dword                      From compile@@lblCallStack:( compile@@ptrCallStack - ( compile@@sizeCallStack * offs ) + 0x08 )
  Load                                  ptrStack     dword                      From compile@@lblCallStack:( compile@@ptrCallStack - ( compile@@sizeCallStack * offs ) + 0x0c )
  .theAddress                           =                                       theAddress
  .ctrArguments                         =                                       ctrArguments
  .ptrQueque                            =                                       ptrQueque
  .ptrStack                             =                                       ptrStack
End Struc
Struc compile@@popCall
  Local temp
  compile@@ptrCallStack                 =                                       ( compile@@ptrCallStack - compile@@sizeCallStack )
  temp                                  compile@@peekCall
  .theAddress                           =                                       temp.theAddress
  .ctrArguments                         =                                       temp.ctrArguments
  .ptrQueque                            =                                       temp.ptrQueque
  .ptrStack                             =                                       temp.ptrStack
End Struc
compile@@sizeCallStack                  =                                       ( 16 )
compile@@lenCallStack                   =                                       ( 4096 * compile@@sizeCallStack )
compile@@ptrCallStack                   =                                       null
Virtual                                 At null
  compile@@lblCallStack::
    rb                                  ( compile@@lenCallStack )
End Virtual
;( modules )
;{
  compile@@initModules                  Equ
  compile@@finishModules                Equ
  Include 'modules/linux/echo.fmodg'
;}
Macro compile@@decode                   context*, address*, size*, main*
  Local lblFunctions, theFunctions, ctrFunctions, numFunctions, sizeFunctions, hazFunction, myFunction
  ctrFunctions                          =                                       null
  theFunctions                          =                                       null
  sizeFunctions                         =                                       4
  Virtual                               At null
    lblFunctions::
      RD                                numFunctions                            ;fbc address
  End Virtual
  Struc getFunction                     offs*
    Local temp
    Load                                temp dword                              From lblFunctions:( offs * sizeFunctions )
    .                                   =                                       ( temp )
  End Struc
  Macro addFunction                     fbcAddress*
    Store                               dword fbcAddress                        At lblFunctions:( ctrFunctions * sizeFunctions )
    ctrFunctions                        =                                       ( ctrFunctions + 1 )
  End Macro
  Local lblJumps, ctrJumps, numJumps, sizeJumps, addJump
  ctrJumps                              =                                       null
  sizeJumps                             =                                       8
  Virtual                               At null
    lblJumps::
      RD                                numJumps                                ;fbc address
      RD                                numJumps                                ;new address
  End Virtual
  Macro addJump                         fbcAddress*,                            newAddress*
    Store                               dword fbcAddress                        At lblJumps:(( ctrJumps * sizeJumps ) + 0x00 )
    Store                               dword newAddress                        At lblJumps:(( ctrJumps * sizeJumps ) + 0x04 )
    ctrJumps                            =                                       ( ctrJumps + 1 )
  End Macro
  Local operator
  Macro operator                        name*,                                  value*
    If ( yasic@@ptrStack < 32 )
      fail < '[asm:compile] ', name, ' need 2 arguments in stack' >
    End If
    displayDeep '#', name, 10
    yasic@@push                         fbc0@@tOperator,                        ( value )
  End Macro
  Local ptrStart, ptrStopp, ptrMain
  ptrStart                              =                                       ( address )
  ptrStopp                              =                                       ( address + size )
  If (( main >= null ) & ( main < size ))
    ptrMain                             =                                       ( ptrStart + main )
  Else
    ptrMain                             =                                       ( ptrStart )
  End If
  Local instruction, value, temp
  Local numArguments, function
  Local deepness
  Macro displayDeep                     string&
    Repeat ( deepness )
      display '  '
    End Repeat
    display string
  End Macro
  deepness                              =                                       1
  While ( true )
    If (( ptrMain < ptrStart ) | ( ptrMain >= ptrStopp ))
      fail '[asm:compile] invalid instruction-pointer'
    End If
    Load                                instruction byte                        From context:( ptrMain )
    ;display 'addr: 0x'
    ;displayHexWord ptrMain
    ;display ': '
    ptrMain                             =                                       ( ptrMain + 1 )
    ;displayValue 'inst: 0x', instruction
    If      ( instruction = fbc0@@opPushByte )
      Load                              value byte                              From context:( ptrMain )
      displayDeep '#pushByte 0x'
      displayHexByte value
      display 10
      ptrMain                           =                                       ( ptrMain + 1 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x00000080 ) * 0xffffffffffffff00 ) or value )
    Else If ( instruction = fbc0@@opPushWord )
      Load                              value word                              From context:( ptrMain )
      displayDeep '#pushWord 0x'
      displayHexWord value
      display 10
      ptrMain                           =                                       ( ptrMain + 2 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x00008000 ) * 0xffffffffffff0000 ) or value )
    Else If ( instruction = fbc0@@opPushDWord )
      Load                              value dword                             From context:( ptrMain )
      displayDeep '#pushDWord 0x'
      displayHexDWord value
      display 10
      ptrMain                           =                                       ( ptrMain + 4 )
      yasic@@push                       fbc0@@tConstant,                        ((( value and 0x80000000 ) * 0xffffffff00000000 ) or value )
    Else If ( instruction = fbc0@@opPushQWord )
      Load                              value qword                             From context:( ptrMain )
      displayDeep '#pushQWord 0x'
      displayHexQWord value
      display 10
      ptrMain                           =                                       ( ptrMain + 8 )
      yasic@@push                       fbc0@@tConstant,                        ( value )
    Else If ( instruction = fbc0@@opAdd )
      operator                          'add',                                  instruction
    Else If ( instruction = fbc0@@opSub )
      operator                          'sub',                                  instruction
    Else If ( instruction = fbc0@@opMul )
      operator                          'mul',                                  instruction
    Else If ( instruction = fbc0@@opDiv )
      operator                          'div',                                  instruction
    Else If ( instruction = fbc0@@opMod )
      operator                          'mod',                                  instruction
    Else If ( instruction = fbc0@@opNot )
      operator                          'not',                                  instruction
    Else If ( instruction = fbc0@@opAnd )
      operator                          'and',                                  instruction
    Else If ( instruction = fbc0@@opOr )
      operator                          'or',                                   instruction
    Else If ( instruction = fbc0@@opXor )
      operator                          'xor',                                  instruction
    Else If ( instruction = fbc0@@opLogicalNot )
      operator                          'lnot',                                 instruction
    Else If ( instruction = fbc0@@opLogicalAnd )
      operator                          'land',                                 instruction
    Else If ( instruction = fbc0@@opLogicalOr )
      operator                          'lor',                                  instruction
    Else If ( instruction = fbc0@@opLogicalXor )
      operator                          'lxor',                                 instruction
    Else If ( instruction = fbc0@@opFunction )
      Load                              temp dword                              From context:( ptrMain + fbc0@@offFunctionMyName - 1 )
      If      ( compile@@ptrStringYapter = null )
        fail '[asm:compile] there is no string-yapter'
      Else If (( temp < 2 ) | (( compile@@lenStringYapter - temp ) < 0 ))
        fail '[asm:compile] pointer out of bonds'
      Else
        Load                            lenght word                             From context:( compile@@ptrStringYapter + temp - 2 )
        If (( compile@@lenStringYapter - temp ) < lenght )
          fail '[asm:compile] corrupted string'
        End If
        displayDeep ''
        Repeat ( lenght )
          Load                          char byte                               From context:( compile@@ptrStringYapter + temp + % - 1 )
          display char
        End Repeat
        display '()', 10
        displayDeep '{', 10
        deepness                        =                                       ( deepness + 1 )
        ptrMain                         =                                       ( ptrMain + fbc0@@lenFunctionHeader - 1 )
      End If
    Else If ( instruction = fbc0@@opLoop )
      temp                              yasic@@popArgument                      true
      displayDeep '#loop', 10
      displayDeep '#{', 10
      deepness                          =                                       ( deepness + 1 )
      ptrMain                           compile@@pushCall                       ( temp.value + ptrStart )
    Else If ( instruction = fbc0@@opBreak )
      displayDeep                       '#break', 10
    Else If ( instruction = fbc0@@opDone )
      deepness                          =                                       ( deepness - 1 )
      displayDeep '#}', 10
      temp                              compile@@popCall
;      If (( temp.ptrStack - yasic@@ptrStack ) = temp.ctrArguments * 16 )
;        fail '[asm:compile] stack-pointer after call must be equal to stack-pointer before call minus arguments'
;      End If
      ptrMain                           =                                       ( temp.theAddress )
      yasic@@ptrQueque                  =                                       ( temp.ptrQueque )
    Else If ( instruction = fbc0@@opAllocLocal )
      displayDeep '#allocLocal', 10
    Else If ( instruction = fbc0@@opLet )
      displayDeep '#let', 10
    Else If ( instruction = fbc0@@opCall )
      temp                              yasic@@popArgument                      true
      myFunction                        =                                       temp.value
      Load                              temp byte                               From context:( ptrStart + myFunction + fbc0@@offFunctionInstruction )
      If ( temp = fbc0@@opFunction )
        Load                            temp dword                              From context:( ptrStart + myFunction + fbc0@@offFunctionMyName )
        If      ( compile@@ptrStringYapter = null )
          fail '[asm:compile] there is no string-yapter'
        Else If (( temp < 2 ) | (( compile@@lenStringYapter - temp ) < 0 ))
          fail '[asm:compile] pointer out of bonds'
        Else
          Load                          lenght word                             From context:( compile@@ptrStringYapter + temp - 2 )
          If (( compile@@lenStringYapter - temp ) < lenght )
            fail '[asm:compile] corrupted string'
          End If
          displayDeep '#call '
          Repeat ( lenght )
            Load                        char byte                               From context:( compile@@ptrStringYapter + temp + % - 1 )
            display char
          End Repeat
          display ' -> (0x'
          displayHexWord ( myFunction )
          display ')', 10
          hazFunction                   =                                       nil
          Repeat ( ctrFunctions ), offs:( null )
            temp                        getFunction                             offs
            If ( temp = function )
              hazFunction               =                                       ctrFunction
              Break
            End If
          End Repeat
          If ( hazFunction = nil )
            addFunction                 myFunction
          End If
        End If
      Else
        fail '[asm:compile] this type of call is not implemented yet'
      End If
    Else If ( instruction = fbc0@@opStop )
      deepness                          =                                       ( deepness - 1 )
      displayDeep '}', 10
      If ( theFunctions = ctrFunctions )
        Break
      Else
        temp                            getFunction                             theFunctions
        If (( temp >= null ) & ( temp < size ))
          ptrMain                       =                                       ( ptrStart + temp )
          theFunctions                  =                                       ( theFunctions + 1 )
        Else
          fail '[asm:compile] uhm, thats weird'
        End If
      End If
    Else
      temp                              fbc0@@mnemonic                          instruction
      displayValue 'instruction: 0x', instruction
      fail < '[asm:compile] invalid instruction: »', temp, '«' >
    End If
  End While
  Purge operator
  numFunctions                          =                                       ( ctrFunctions )
  numJumps                              =                                       ( ctrJumps )
End Macro
Macro compile@@buildYapter              address,  type,     size,     resv,     misc,     pointer,  dword0,   dword1,   dword2,   lblInputFile
  If ( compile@@lenMagic = 0 )
    compile@@lenMagic                   =                                       ( address )
    Repeat ( compile@@lenMagic )
      Load                              char byte                               From lblInputFile:( % - 1 )
      db                                char
    End Repeat
  End If
  If      ( type = null )
    compile@@ycontent                   =                                       ( address + 16 )
    Break
  Else If ( type = fbc0@@yBytecode )
    ;type : machine : size : main : pointer
    uf4@@newLayer
      Repeat ( dword0 ), offs:( 0 )
        Load                            char byte                               From lblInputFile:( compile@@ycontent + dword2 + offs )
        db                              char
      End Repeat
    temp                                uf4@@endLayer
    uf4@@addYapterD                     type,     size,     temp.size,          dword1,             temp
  Else If ( type = fbc0@@yStrings )
    ;type : null : size : null : pointer
    uf4@@newLayer
      Repeat ( dword0 ), offs:( 0 )
        Load                            char byte                               From lblInputFile:( compile@@ycontent + dword2 + offs )
        db                              char
      End Repeat
    temp                                uf4@@endLayer
    uf4@@addYapterD                     type,     size,     temp.size,          dword1,             temp
    compile@@ptrStringYapter            =                                       ( compile@@ycontent + dword2 )
    compile@@lenStringYapter            =                                       dword0
;    displayValue '*0x', compile@@ptrStringYapter
  Else
    displayValue 'type: 0x', type
    fail '[asm:compile] unknown yapter-type'
  End If
End Macro
Macro compile@@loadYapter               address,  type,     size,     resv,     misc,     pointer,  dword0,   dword1,   dword2,   lblInputFile
  Local offs, lenght, char
  If      ( type = null )
    Break
  Else If ( type = fbc0@@yBytecode )
    If ( size = fbc0@@version )
      code amd64
        compile@@decode                 lblInputFile,                           ( dword2 + compile@@ycontent ),         dword0,   dword1
      end code
    End If
  Else If ( type = fbc0@@yStrings )
  End If
End Macro

format                                  uf4,                                    128,                                    ( 4096 * 4096 )
  import 'display'
  import 'x86/amd64'
  uf4@@parseFile                        compile@@theInputFile,                  compile@@buildYapter,                   compile@@loadYapter
end format
